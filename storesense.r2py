"""
<Program Name>
  storesense.r2py

<Started>
  20 August 2014

<Author>
  Seth Miller (NYU)

<Purpose>
  This is a library for POSTing sensor data to a
  website (sensevis.poly.edu) for backhauling.

Example Use:
  # In your program, import this library:
  dy_import_module_symbols('storesense.r2py')

  device_id = request_data(my_sensor_socket, 'getSubscriberID', [])
  
  data = []
  measurements = {}
  
  # Collect some data...
  for x in range(0, 10):
    measurements['gps'] = getLocation()
    measurements['speed'] = getSpeed()
    measurements['fuel_level'] = getFuelLevel()
    measurements['fuel_consumption'] = getFuelConsumption()
    # Each data entry requires a timestamp for the POST to succeed.
    data.append(storesense_timestamp(measurements))

  storesense_post(data, device_id, 'mycollection', 'myusername')
   
"""

urllib = dy_import_module("urllib.r2py")
time = dy_import_module("time.r2py")
json = dy_import_module("json.r2py")



POST_DELIMITER = '\n\n\n'

RECONNECT_WAIT_TIME = 5

_fileproperties = {'buffered':False, 'lock':createlock()}

time.time_updatetime(list(getresources()[0]['messport'])[0])


# Contructs a POST out of sensor data
def _buildpost(data, device_id, collection, user):
  # POSTs to sensevis must have the user's device id (IMEI number) 
  # for differentiating end-user devices.  It also needs the sensor 
  # data in JSON so it can be deserialized server-side.  Finally, the 
  # post needs the name of which collection we're backhauling data into
  # and the user it belongs to.
  datastr = 'id=' + urllib.urllib_quote(device_id) + \
      '&entries=' + urllib.urllib_quote(json.dumps(data)) + '&collection='+urllib.urllib_quote(collection) + \
      '&user=' + urllib.urllib_quote(user)
  
  # Since the POST is simple, we'll build it ourselves.
  post = 'POST /main/ HTTP/1.1' + \
      '\nHost: sensevis.poly.edu' + \
      '\nContent-Type: application/x-www-form-urlencoded' + \
      '\nContent-Length: '+str(len(datastr)) + \
      '\n\n' + datastr

  return post




# Find and return a socket object to the first open port.
def _getsocket():
  ports = list(getresources()[0]['connport'])
  for port in ports:
    try:
      # Open a connection with sensevis.poly.edu
      socketobject = openconnection('128.238.63.68', 80, \
          getmyip(), int(port), RECONNECT_WAIT_TIME)
      return socketobject
    # The port wasn't open, so keep looking.
    except ResourceForbiddenError or DuplicateTupleError \
        or AlreadyListeningError or CleanupInProgressError:
      continue
  # No ports were open...
  return None




# Writes a POST to a buffer file, so it can be sent later.
# Then it starts a new thread to send the buffer if one hasn't 
# already been created.
def _write_to_buffer(post):
  _fileproperties['lock'].acquire(True)
  fileobject = openfile('postbuffer.txt', True)
  eof = len(fileobject.readat(None, 0)) 
  fileobject.writeat(post+POST_DELIMITER, eof)
  fileobject.close()
  _fileproperties['lock'].release()
  
  if not _fileproperties['buffered']:
      _fileproperties['buffered'] = True
      createthread(_sendbuffer)


    
# Retrieves all the POSTs in the buffer file starting from 
# the offest
def _getbuffer(offset):
  posts = []
  _fileproperties['lock'].acquire(True)
  fileobject = openfile('postbuffer.txt', True)
  try:
    posts = fileobject.readat(None, offset).split(POST_DELIMITER)
  except SeekPastEndOfFileError:
    pass
  finally:
    fileobject.close()
    _fileproperties['lock'].release()
    return posts



# Sends all the POSTs in the buffer file and then removes the file.
def _sendbuffer():
  socket = None
  posts = _getbuffer(0)
  eof = 0
  while len(posts) > 0:
    for post in posts:
      eof += len(post+POST_DELIMITER)
    eof -= len(POST_DELIMITER)

    count = 0
    while count < len(posts):
      try:
        if socket is None:
          socket = _getsocket()
        socket.send(posts[count])
        if socket.recv(3) == '200':
          count += 1
      except Exception as e:
        if not isinstance(e, SocketWouldBlockError):
          socket = None
        sleep(RECONNECT_WAIT_TIME)
        continue 
    # Check if any new POSTs have been 
    # made since starting this thread.
    posts = _getbuffer(eof)
  
  socket.close()
  _fileproperties['buffered'] = False
  removefile('postbuffer.txt')
    

  

def storesense_post(data, device_id, collection, user):
  """
  <Purpose>
    POSTs sensor data to a website (sensevis.poly.edu) where it
    can be stored into a database.

  <Arguments>
    data:
        A list of sensor data entries (dicts) to be POSTed.
    collection:
        The name of the collection the data will be stored into.
    user:
        The username of the person owning the specified collection.

  <Exceptions>
    HttpError 403:
        Missing permission to access the given collection or the
        collection does not exist. (The latter is not a 404 error, 
        as this would potentially expose the existence of private 
        collections to the public.) 
    TypeError:
        The form of the given data is incorrect. 
            

  <Side Effects>
    None.

  <Returns>
    None.
  """
  post = _buildpost(data, device_id, collection, user)
  try:
    socket = _getsocket()
    socket.send(post)
    if socket.recv(3) != '200':
      _write_to_buffer(post)
    socket.close()
  except AttributeError or TimeoutError or InternetConnectivityError \
      or SocketClosedLocal or SocketClosedRemote or SocketWouldBlockError as e:
    if not isinstance(e, AttributeError):
      socket.close()
    _write_to_buffer(post)




def storesense_timestamp(entry):
  """
  <Purpose>
    Places a timestamp of the current time on the given data entry,
    prepping the form of the entry for eventual POSTing.

  <Arguments>
    entry:
      A dict of sensor data literally just collected, whose keys are
      the names of your sensors or measurements.  The dict's values 
      are those of the data collected. 
      (E.g. entry = {'gps':(49.372, -73.998), 'batteryLevel':74})
    
  <Exceptions>
    TypeError:
        Raised if 'entry' is not a dict.

  <Side Effects>
    None.

  <Returns>
    A dict containing the given entry dict, as well as the (current) 
    time the sensor data was collected.
  """
  return {'time':time.time_getunixtime(), 'sensors':entry} 
